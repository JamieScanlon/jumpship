//////////////////////////////////////////////////////////////////////////////////// JumpShip Framework for AS3// Copyright 2008 Jamie Scanlon//// Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the "Software"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS // IN THE SOFTWARE.//// Project: JumpShip Framework - Core// File: JSEnumerable.as// Created by: Jamie Scanlon//////////////////////////////////////////////////////////////////////////////////// This class provides utility functions for enumerable objects making it easy// to traverse data structures in a Ruby-esque manner. Much of the code was// adapted from the Enumberable object in the Prototype library for JavaScript.//// This class also lets you use [ ] array notation to access the data. // Much of the code for these functions were derived from the Collection data// structure that is used throuout the Flex Framework. The goal here is to// provide a basis for a data structure that is grounded in the standard// prncipals of Ruby / Prototype but also is mindful of the future direction// and common practices of Flash / Flex//// In order to be as flexible as possible, this class also implements// IEventDispatcher.package com.jsjstudios.jumpship.core{		////////////////////////////////////////////////////////////////////////////////	// Imports	////////////////////////////////////////////////////////////////////////////////		import flash.utils.Proxy;	import flash.utils.flash_proxy;	import flash.events.IEventDispatcher;	import flash.events.EventDispatcher;	import flash.events.Event;		////////////////////////////////////////////////////////////////////////////////	//	//	// Class: JSEnumerable	//	//	////////////////////////////////////////////////////////////////////////////////		/** 	 *	A Base class that provides basic Enumeration methods that help search, sort,	 *	and traverse data structures.	 */	public class JSEnumerable extends Proxy implements IEventDispatcher	{				////////////////////////////////////////////////////////////////////////////		// Event Dispatcher proxy		////////////////////////////////////////////////////////////////////////////				private var eventDispatcher:EventDispatcher;				////////////////////////////////////////////////////////////////////////////		// Aliases		////////////////////////////////////////////////////////////////////////////				/** 		 *	An alias for the collect method		 */		public var map:Function = collect;				/** 		 *	An alias for the findAll method		 */		public var select:Function = findAll;				/** 		 *	An alias for the incl method		 */		public var member:Function = incl;				/** 		 *	An alias for the toArray method		 */		public var entries:Function = toArray;				////////////////////////////////////////////////////////////////////////////		//		// Constructor		//		////////////////////////////////////////////////////////////////////////////		/** 		 *	Constructor		 */		public function JSEnumerable ( )		{						eventDispatcher = new EventDispatcher();					}				////////////////////////////////////////////////////////////////////////////		//		// Public Methods		//		////////////////////////////////////////////////////////////////////////////			/** 		 *	A method that calls a function for each item in the data set		 *	@param iterator A function that gets called iteratively with the item		 */		public function each(iterator:Function):* {						var index:uint = 0;						doEach(function (value:*):* {				iterator(value, index++);			});						return this;					}				/** 		 *	A method that calls the <code>map</code> method on an array		 *	using the <code>iterator</code> function on slices		 *	of the data set each with a size given by <code>num</code>		 *	@param num		 *	@param iterator		 *	@return An array of results from <code>Array.map</cope>		 *	@see Array		 */		public function eachSlice(num:uint, iterator:Function):* {						var index:uint = -num;			var slices:Array = [];			var array:Array = toArray();						while ((index += num) < array.length) {				slices.push(array.slice(index, index+num));			}			    		return slices.map(iterator);					}				/** 		 *	A method that returns the item of the data set at the given index		 *	@param index		 *	@param ... args		 *	@return An item in the data set or an array of results if more than one is found		 */		public function getItemAt(index:int, ... args):* {						var myResult:Array = findAll(function (value:*, myIndex:int):* {				return myIndex == index;			});						if (myResult.length > 0) {								return myResult[0];							} else {								return null;							}						}				/** 		 *	A method that sets the item of the data set at the given index. 		 *	This function should be defined in the class that inherits from this one		 *	since this class does not reference any data structure directly and 		 *	therefore can't modify it.		 *	@param value		 *	@param index		 *	@param ... args		 */		public function setItemAt(value:Object, index:int, ... args):* {}				/** 		 *	A method that calls a function iteratively with each item in the data set 		 *	and returns true when the result of the function is true for all items		 *	@param iterator		 *	@return a true / false result		 */		public function all(iterator:Function):* {						var result:Boolean = true;						each(function (value:*,index:int):* {				result = result && iterator(value,index);			});						return result;					}				/** 		 *	A method that calls a function iteratively with each item in the data set 		 *	and returns true when the result of the function is true for any items		 *	@param iterator		 *	@return a true / false result		 */		public function any(iterator:Function):* {						var result:Boolean = false;						each(function (value:*,index:int):* {				if (!result) {					result = iterator(value,index);				}			});						return result;					}				/** 		 *	A method that calls a function for each item in the data set and puts 		 *	the result into an array		 *	@param iterator An optional function that gets called iteratively with the item		 *	and the index and return a value. The default function returns the item itself.		 *	@return An array of results from 'iterator'		 */		public function collect( iterator:Function = null ):* {						if (iterator == null) {				iterator = __defaultFunc;			}						var results:Array = [];						each(function (value:*,index:int):* {				results.push( iterator(value,index) );			});						return results;					}				/** 		 *	A method that calls a function iteratively with each item in the data set 		 *	and returns the item when the result of the function is true for any item		 *	@param iterator		 *	@return a true / false result		 */		public function detect(iterator:Function):* {						var result:* = false;						each(function (value:*,index:int):* {				if ( iterator(value,index) && !result ) {					result = value;				}			});						return result;					}				/** 		 *	A method that calls a function iteratively with each item in the data set 		 *	and returns an array of items for which the result of the function is true		 *	@param iterator		 *	@return a true / false result		 */		public function findAll(iterator:Function):* {						var results:Array = [];						each(function (value:*,index:int):* {				if ( iterator(value,index) ) {					results.push( value );				}			});						return results;					}				/** 		 *	A method that calls a toString iteratively with each item in the data set 		 *	and returns an array of values returned from the iterator where result of the RegExp is true		 *	@param pattern		 *	@param iterator		 *	@return a true / false result		 */		public function grep(pattern:RegExp, iterator:Function):* {						var results:Array = [];						each(function (value:*,index:int):* {				var stringValue:String = value.toString();				if ( pattern.test(stringValue) ) {					results.push( iterator(value,index) );				}			});						return results;					}				/** 		 *	A method that iteratively compares each item in the data set with an object		 *	and returns true if any item matches the object.		 *	@param object		 *	@return a true / false result		 */		public function incl(object:*):* {						var found:Boolean = false;						each(function (value:*):* {				if ( value == object ) {					found = true;				}			});						return found;					}				/** 		 *	A method that iteratively passes an object into an iterator function for		 *	eash item in the data set and uses the returned value to pass into the next		 *	item. Returns the final result.		 *	@param memo		 *	@param iterator		 *	@return an object		 */		public function inject(memo:*, iterator:Function):* {						each(function(value:*, index:int):* {				memo = iterator(memo, value, index);			});						return memo;					}				/** 		 *	Iteratively calls a method for each item in the data set		 *	 and returns an array of results.		 *	@param method		 *	@param ... args		 *	@return an array of results		 */		public function invoke(method:*, ... args):* {						return map(function(value:*):* {   				return value[method].apply(value, args);			});					}				/** 		 *	Iteratively calls an iterator function for each item in the data set		 *	 and returns the largest result.		 *	@param iterator		 *	@return A result object		 */		public function max(iterator:Function):* {						var result:*;						each(function (value:*, index:int):* {				value = iterator(value, index);				if (result == null || value >= result) {					result = value				}			});						return result;					}				/** 		 *	Iteratively calls an iterator function for each item in the data set		 *	 and returns the smallest result.		 *	@param iterator		 *	@return A result object		 */		public function min(iterator:Function):* {						var result:*;						each(function (value:*, index:int):* {				value = iterator(value, index);				if (result == null || value < result) {					result = value				}			});						return result;					}				/** 		 *	Iteratively takes a proterty from each item in the data set		 *	 and returns an array of the results.		 *	@param property The name of the property to retrieve		 *	@return A result array		 */		public function pluck(property:String):* {						var results:Array = [];						each(function(value:*, index:int):* {				results.push(value[property]);			});						return results;					}				/** 		 *	Calls a function iteratively for eac item in the data set and returns		 *	an array of items for which the result of the functino was false.		 *	@param iterator		 *	@return A result array		 */		public function reject(iterator:Function):* {						var results:Array = [];						each(function (value:*, index:int):* {				if (!iterator(value, index)) {					results.push(value);				}			});						return results;					}				/** 		 *	Builds a new array with all the items in the data set sorted according		 *	to the result of a function called on each item		 *	@param iterator		 *	@return A result array		 */		public function sortBy(iterator:Function):* {						var results:Array = [];						var temp:Array =  map(function(value:*, index:int):* {				return {value: value, criteria: iterator(value, index)};			}).sort(function(left:*, right:*):* {				var a:* = left.criteria;				var b:* = right.criteria;				return a < b ? -1 : a > b ? 1 : 0;			});						for (var i:int = 0; i < temp.length; i++) {				results.push(temp[i].value);			}				 			return results;					}				/** 		 *	Builds a new array of all items in the data set		 *	@return A result array		 */		public function toArray():Array {			return map();		}				/** 		 *	Returns the size of the data set by first converting t to and array		 *	and then taking the length.		 *	@return A result interger		 */		public function size():int {						return toArray().length;					}				////////////////////////////////////////////////////////////////////////////		//		// Proxy methods		//		////////////////////////////////////////////////////////////////////////////				// The following lets you use [ ] array notation to access the data. 				/**		 *	@inheritDoc		 */		override flash_proxy function getProperty(name:*):* {						if (name is QName) {				name = name.localName;			}						//else name is String			var index:int = -1;						try {				//if they passed in a number (5.5) it will be floored				var n:Number = parseInt(String(name));								if (!isNaN(n)) {					index = int(n);				} 							} catch (e:Error) {} //localName was not a number						if (index == -1) {								var message:String = "unknownProperty"+name+" in JSEnumerable";				throw new Error(message);							} else {								return getItemAt(index)							}		}			/**		 *	@inheritDoc		 */		override flash_proxy function setProperty(name:*, value:*):void {						if (name is QName) {								name = name.localName;			}						//else name is String			var index:int = -1;						try {								//if they passed in a number (5.5) it will be floored				var n:Number = parseInt(String(name));								if (!isNaN(n)) {					index = int(n);				}							} catch (e:Error) {} //localName was not a number						if (index == -1) {								var message:String = "unknownProperty"+name+" in JSEnumerable";				throw new Error(message);							} else {								setItemAt(value, index)							}		}				/**		 *	@inheritDoc		 */		override flash_proxy function hasProperty(name:*):Boolean {						// Check for XML			if (name is QName) {								name = name.localName;						}						//else name is String			var index:int = -1;						try {								//if they passed in a number (5.5) it will be floored				var n:Number = parseInt(String(name));								if (!isNaN(n)) {										index = int(n);								}						} catch (e:Error) {} //localName was not a number						if (index == -1) {								return false;						}				return (index >= 0 && index < length);				}				/**		 *	@inheritDoc		 */		override flash_proxy function nextNameIndex(index:int):int {						return index < length ? index + 1 : 0;					}				/**		 *	@inheritDoc		 */		override flash_proxy function nextName(index:int):String {						return (index-1).toString();					}				/**		 *	@inheritDoc		 */		override flash_proxy function nextValue(index:int):* {						return getItemAt(index - 1);					}				/**		 *	@inheritDoc		 */		override flash_proxy function callProperty(name:*, ... rest):*		{			return null;		}				////////////////////////////////////////////////////////////////////////////		//		// IEventDispatcher Methods		//		////////////////////////////////////////////////////////////////////////////		/**		 *	IEventDispatcher addEventListener implementation		 *	@see flash.events.IEventDispatcher		 */		public function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void		{						eventDispatcher.addEventListener(type, listener, useCapture, priority, useWeakReference)					}				/**		 *	IEventDispatcher dispatchEvent implementation		 *	@see flash.events.IEventDispatcher		 */		public function dispatchEvent(event:Event):Boolean		{						return eventDispatcher.dispatchEvent(event);					}				/**		 *	IEventDispatcher hasEventListener implementation		 *	@see flash.events.IEventDispatcher		 */		public function hasEventListener(type:String):Boolean		{						return eventDispatcher.hasEventListener(type);					}				/**		 *	IEventDispatcher removeEventListener implementation		 *	@see flash.events.IEventDispatcher		 */		public function removeEventListener(type:String, listener:Function, useCapture:Boolean = false):void		{						eventDispatcher.removeEventListener(type, listener, useCapture)					}				/**		 *	IEventDispatcher willTrigger implementation		 *	@see flash.events.IEventDispatcher		 */		public function willTrigger(type:String):Boolean		{						return eventDispatcher.willTrigger(type);					}				/**		 * Returns the a String description of this model.		 * @return a String.		 */		public function toString():String		{						return "[object JSEnumerable]";					}					////////////////////////////////////////////////////////////////////////////		//		// Private Methods		//		////////////////////////////////////////////////////////////////////////////				/**		 *	A hook function that gets called to perform the iteration over the items		 *	in the collection. Since this class has no way of knowing how to iterate		 *	over it's children ( since it does not enforce a datatype ) this function		 *	must be defined in the subclass		 */		protected function doEach(iterator:Function):* {};				/**		 *	@private		 */		private function __defaultFunc(value:*, ... args):* {			return value;		}			}	// Class End	} // Package End