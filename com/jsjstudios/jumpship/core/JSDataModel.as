//////////////////////////////////////////////////////////////////////////////////// JumpShip Framework for AS3// Copyright 2008 Jamie Scanlon//// Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the "Software"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS // IN THE SOFTWARE.//// Project: JumpShip Framework - Core// File: JSDataModel.as// Created by: Jamie Scanlon//////////////////////////////////////////////////////////////////////////////////package com.jsjstudios.jumpship.core{	////////////////////////////////////////////////////////////////////////////////	// Imports	////////////////////////////////////////////////////////////////////////////////		//import flash.events.Event;	//import flash.events.EventDispatcher;	import com.jsjstudios.jumpship.core.events.*;		////////////////////////////////////////////////////////////////////////////////	// Compiler Meta	////////////////////////////////////////////////////////////////////////////////	[Event(name="dataChange", type="fl.events.DataChangeEvent")]		////////////////////////////////////////////////////////////////////////////////	// Meta	////////////////////////////////////////////////////////////////////////////////	/**	* This Class implements the same events as the flash dataProvider components	* for the sake of cross compatability. As a result you mus have the fl.events.DataChangeEvent	* in you class path to use this class without triggering errors. In an effort to	* be annoying, Adobe has not included this class in the standard class path but you can add it	* or include a component into you library which add the class automatically.	*/	[Event(name=DataChangeEvent.DATA_CHANGE, type="fl.events.DataChangeEvent")]		////////////////////////////////////////////////////////////////////////////////	//	//	// Class: JSDataModel	//	//	////////////////////////////////////////////////////////////////////////////////		/**	* Data Model Class.	* Inheritance JSDataModel -> EventDispatcher -> Object	* Takes two parameters in the constructor. new JSDataModel ( theNames:Array = null , theItems:Array = null )	* theNames is an array of colum names, theItems is the name-value pairs to populate the JSDataModel with.	*/	public class JSDataModel extends JSEnumerable	{				// 		// Properties ( Backers )		//		/**		 *	@private		 */		protected var _hasOne:Array;		/**		 *	@private		 */		protected var _hasMany:Array;		/**		 *	@private		 */		protected var _modelName:String;				// 		// Private variables		//		/**		 *	An Array which stores the list of JSDataRecord instances.		 */		protected var itemsList:Array;		/**		 *	An Array which stores the list of titles or column names.		 */		protected var titlesList:Array;				// 		// Constants		//		protected var IDCOUNTER:uint = 0;			////////////////////////////////////////////////////////////////////////////		//		// Constructor		//		////////////////////////////////////////////////////////////////////////////				/**		 *	Constructor.		 *	@param theNames An Array of column names this instance will manage.		 *	@param theItems An Array of JSDataRecord instances to populate this istance with.		 */		function JSDataModel ( theNames:Array = null , theItems:Array = null )		{						// The titlesList is used to keep track of the column names			// and the column order. The JSDataRecord objects don't care			// how their attributes (column items) are ordered so this			// is somewhat artificial but it helps to visualize						titlesList = new Array();						itemsList = new Array();						_hasOne = new Array();						_hasMany = new Array();						_modelName = "model";						if (theNames != null) {								titlesList = theNames;							}						if (theItems != null) {								for (var i:int = 0; i < theItems.length; i++) {										addItem(theItems[i]);									}							}													}				////////////////////////////////////////////////////////////////////////////		//		// Public Methods		//		////////////////////////////////////////////////////////////////////////////				/**		 * Adds a column to the Model		 * @param theName A string with the name of the new column		 * @param theValues An object with which to populate the new column. Takes the form		 * { id:value, id:value, id:value, ... }		 * @see public function addColumnAt(theName:String, theIndex:int, theValues:Object):void		 * @see public function updateColumn(theName:String, theValues:Object):void		 * @see public function removeColumn(theName:String):void		 * @see public function removeColumnAt(theIndex:int):void		 * @see public function getColumn(theName:String):Object		 * @see public function getColumnAt(theIndex:int):Object		 */		public function addColumn(theName:String, theValues:Object):void {						// theValues is an object to populat the new column. It should take the			// form { id:value, id:value, id:value }						titlesList.push(theName);						each(function (item:*):* {												item.addAttribute(theName, theValues[item.id]);							});					}				/**		 * Adds a column to the Model at a specific location		 * @param theName A string with the name of the new column		 * @param theIndex An interger (zero indexed) that specifies where to add the column		 * @param theValues An object with which to populate the new column. Takes the form		 * { id:value, id:value, id:value, ... }		 * @see public function addColumn(theName:String, theValues:Object):void		 * @see public function updateColumn(theName:String, theValues:Object):void		 * @see public function removeColumn(theName:String):void		 * @see public function removeColumnAt(theIndex:int):void		 * @see public function getColumn(theName:String):Object		 * @see public function getColumnAt(theIndex:int):Object		 */		public function addColumnAt(theName:String, theIndex:int, theValues:Object):void {						// theValues is an object to populate the new column. It should take the			// form { id:value, id:value, id:value }						titlesList.splice(theIndex,0,theName);						each(function (item:*):* {												item.addAttribute(theName, theValues[item.id]);							});					}				/**		 * Updates a column with the values provided.		 * @param theName A string with the name of the new column		 * @param theValues An object with which to populate the new column. Takes the form		 * { id:value, id:value, id:value, ... }		 * @see public function addColumn(theName:String, theValues:Object):void		 * @see public function addColumnAt(theName:String, theIndex:int, theValues:Object):void		 * @see public function removeColumn(theName:String):void		 * @see public function removeColumnAt(theIndex:int):void		 * @see public function getColumn(theName:String):Object		 * @see public function getColumnAt(theIndex:int):Object		 */		public function updateColumn(theName:String, theValues:Object):void {						// theValues is an object to populat the new column. It should take the			// form { id:value, id:value, id:value }						each(function (item:*):* {												item.update(theName, theValues[item.id]);							});						dispatchEvent(new DataChangeEvent(DataChangeEvent.DATA_CHANGE, "change", itemsList, 0, itemsList.length-1));					}				/**	 	 * Removes a column.		 * @param theName A string with the name of the new column		 * @see public function addColumn(theName:String, theValues:Object):void		 * @see public function addColumnAt(theName:String, theIndex:int, theValues:Object):void		 * @see public function updateColumn(theName:String, theValues:Object):void		 * @see public function removeColumnAt(theIndex:int):void		 * @see public function getColumn(theName:String):Object		 */		public function removeColumn(theName:String):void {						each(function (item:*):* {												item.removeAttribute(theName);							});						for (var j:int = 0; j < titlesList.length; j++) {								if (titlesList[j] == theName) {										titlesList.splice(j,1);									}							}					}				/**		 * Removes a column at the specified index.		 * @param theIndex An interger (zero indexed) that specifies which column to remove		 * @see public function addColumn(theName:String, theValues:Object):void		 * @see public function addColumnAt(theName:String, theIndex:int, theValues:Object):void		 * @see public function updateColumn(theName:String, theValues:Object):void		 * @see public function removeColumn(theName:String):void		 * @see public function getColumn(theName:String):Object		 * @see public function getColumnAt(theIndex:int):Object		 */		public function removeColumnAt(theIndex:int):void {						var theName:String = titlesList[theIndex];						titlesList.splice(theIndex,1);			each(function (item:*):* {												item.removeAttribute(theName);							});					}				/**		 * Returns the values of a column in the form of an object.		 * @param theName A string with the name of the new column		 * @return an object containing the column values in the form { id:value, id:value, id:value, ... }		 * @see public function addColumn(theName:String, theValues:Object):void		 * @see public function addColumnAt(theName:String, theIndex:int, theValues:Object):void		 * @see public function updateColumn(theName:String, theValues:Object):void		 * @see public function removeColumn(theName:String):void		 * @see public function removeColumnAt(theIndex:int):void		 * @see public function getColumnAt(theIndex:int):Object		 */		public function getColumn(theName:String):Object {						// tempObj takes the form { id:value, id:value, id:value }						var tempObj:Object = new Object();			each(function (item:*):* {												tempObj[item.id] = item[theName];							});						return tempObj;					}				/**		 * Returns the values of a column in the form of an object.		 * @param theIndex An interger (zero indexed) that specifies which column to return		 * @return an object containing the column values in the form { id:value, id:value, id:value, ... }		 * @see public function addColumn(theName:String, theValues:Object):void		 * @see public function addColumnAt(theName:String, theIndex:int, theValues:Object):void		 * @see public function updateColumn(theName:String, theValues:Object):void		 * @see public function removeColumn(theName:String):void		 * @see public function removeColumnAt(theIndex:int):void		 * @see public function getColumn(theName:String):Object		 */		public function getColumnAt(theIndex:int):Object {						// tempObj takes the form { id:value, id:value, id:value }						var tempObj:Object = new Object();						each(function (item:*):* {												tempObj[item.id] = item[titlesList[theIndex]];							});						return tempObj;					}				/**		 * Returns the data record at a given index.		 * @param theIndex An interger (zero indexed) that specifies which record to return		 * @return A reference to the data record		 */		public override function getItemAt(theIndex:int, ... args):* {						return itemsList[theIndex];					}				/**		 * Sets the data record at a given index. Same as <code>replaceItemAt()</code> 		 * @param theValue A JSDataRecord to set		 * @param theIndex An interger (zero indexed) that specifies which index to set the record		 */		public override function setItemAt(theValue:Object, theIndex:int, ... args):* {						replaceItemAt( theIndex, ( theValue as JSDataRecord) )					}				/**		 * Returns the data record id at a given index.		 * @param theIndex An interger (zero indexed) that specifies which record id to return		 * @return The id of the data record		 */		public function getItemID(theIndex:int):Object {						// Loosly typed. An Id can be any datatype.			return itemsList[theIndex].id;					}				/**		 * Returns the data record index at a given id.		 * @param theID The ID of the record whose index will be returned.		 * @return The index of the data record		 */		public function getItemIndex(theID:Object):int {						// theID is loosly typed. An Id can be any datatype.							var returnIndex:int = -1;						this.each (function ( item:*,index:int):* {				if ( item.id == theID ) {					returnIndex = index;				}			});						return returnIndex;					}				/**		 * Adds a new record item to the Model.		 * @param theItem A JSDataRecord to add		 * @see public function addItemAt(theIndex:int, theItem:JSDataRecord):void		 */		public function addItem(theItem:JSDataRecord):void {						itemsList.push(theItem);						theItem.addEventListener(DataRecordBindingEvent.UPDATE, dataRecordBindingEvent, false, -50, true);						// Make sure the item has all of the columns in this model			for (var i:int = 0; i < titlesList.length; i++) {								if (theItem[titlesList[i]] == undefined) {										theItem.addAttribute(titlesList[i]);									}							}						if (theItem["id"] == undefined) {								// also give this item an id				theItem.addAttribute("id", IDCOUNTER);							}						IDCOUNTER++;						this.dispatchEvent(new DataChangeEvent(DataChangeEvent.DATA_CHANGE, "add", [theItem], itemsList.length-1, itemsList.length-1));					}				/**		 * Adds a new record item to the Model at a specified index.		 * @param theIndex The index (zero indexed) where the item is to be added		 * @param theItem A JSDataRecord to add		 * @see public function addItem(theItem:JSDataRecord):void		 */		public function addItemAt(theIndex:int, theItem:JSDataRecord):void {						theItem.addEventListener(DataRecordBindingEvent.UPDATE, dataRecordBindingEvent, false, -50, true);								itemsList.splice(theIndex, 0, theItem);						// Make sure the item has all of the columns in this model			for (var i:int = 0; i < titlesList.length; i++) {								if (theItem[titlesList[i]] == undefined) {										theItem.addAttribute(titlesList[i]);									}							}						if (theItem["id"] == undefined) {								// also give this item an id				theItem.addAttribute("id", theIndex);							}						IDCOUNTER++;						this.dispatchEvent(new DataChangeEvent(DataChangeEvent.DATA_CHANGE, "add", [theItem], theIndex, theIndex));					}				/**		 * Serch and sort method for record items.		 * @param theMethod The search method, "all" or "first"		 * @param theConditions An optional object the limits the search to the name-value pairs that are given.		 * theConditions takes the form {name1:value1, name2:value2, ... }. In plain english this conducts a 		 * search where the column "name1" has the value "value1" and the column "name2" has the value "value2"		 * @param theOptions One or more optional string parameters that either limits, offsets, orders the result or		 * includes additionsl JSDataModel's in the search ( These JSDataModel's must first be included in the hasOne or 		 * hasMany preoperties). The format for these are {limit:int}, {offset:int}, {order:String}, {include:JSDataModel}.		 * @return an Array of data records or the data record itself (if just one).		 */		public function find(theMethod:String, theConditions:Object = null, theOptions:Object = null):* {						// this function will match the object param and value with the			// list of items. If there is more than one param/value pair, it will			// be treated as an AND search.						// theMethod can either be "all" or "first" which indicates whether			// to return all of the results or just the first.						// theConditions is an object defining which fields and values to search for.  			// The Object takes the form {name1:value1, name2:value2, ... }. In plain 			// english this conducts a search where the column "name1" has the value "value1" 			// and the column "name2" has the value "value2"						// theOptions is an optional parameter defining how the result 			// should be returned. In each case the parameters are Objects with one or more 			// of the following properties:			// order: Specifies the name of a column by which the result should be ordered.			// limit: An integer determining the limit on the number of rows that should be returned.			// offset: An integer determining the offset from where the rows should be fetched. 			// So at 5, it would skip the first 4 rows.			// include: An array of Name associations that should be searched alongside using this search. 			// The symbols named refer to associations previously defined by the hasOne and hasMany properties.							var orderFlag:Boolean = false;			var limitFlag:Boolean = false;			var offsetFlag:Boolean = false;			var includeFlag:Boolean = false;						var i:uint;			var j:uint;			var a:*;			var tempArray:Array;			var tempRecord:*;						var orderBy:String;			var limit:uint;			var offset:uint;			var including:Array;						for (a in theOptions) {								switch (a) {										case "order":						orderFlag = true;						orderBy = theOptions.order;						break;					case "limit":						limitFlag = true;						limit = theOptions.limit;						break;					case "offset":						offsetFlag = true;						offset = theOptions.offset;						break;					case "include":						includeFlag = true;						including = theOptions.including;						break;					default:						break;										}							}						if (theMethod == "all") {								if (!offsetFlag) {										offset = 0;									}								tempArray = findAll(function(item:*, index:int):* {										if (index >= offset) {												var tempFlag:Boolean = true;						  						for (a in theConditions) {														if (item[a] != theConditions[a] && tempFlag) {																	tempFlag = false;															}													}												return tempFlag; 											} else {												return false;											}									});								if (includeFlag) {										for (i = 0; i < including.length; i++) {												for (j = 0; j < _hasOne.length; j++) {															if (including[i] == _hasOne[j]) {																tempRecord = _hasOne[j].find("first", theConditions);																if (tempRecord != undefined) {																		tempArray.push(tempRecord);																	}																}														}													for (j = 0; j < _hasMany.length; j++) {														if (including[i] == _hasMany[j]) {																var tempRecordArray:Array = _hasMany[j].find("all", theConditions);																if (tempRecordArray != null && tempRecordArray.length > 0) {																	tempArray = tempArray.concat(tempRecordArray);																	}															}													}											}									}								if (limitFlag) {										tempArray.splice(limit);									}								if(orderFlag) {										doSort(tempArray, sortCompare, orderBy);									}								return tempArray;											} else if (theMethod == "first") {								return detect(function (item:*):* {										var tempFlag:Boolean = true;										for (a in theConditions) {												if (item[a] != theConditions[a]) {														tempFlag = false;													}											}										if (tempFlag) {												tempArray = new Array();												tempArray.push(item);												if (includeFlag) {														for (i = 0; i < including.length; i++) {																for (j = 0; j < _hasOne.length; j++) {																			if (including[i] == _hasOne[j]) {																				tempRecord = _hasOne[j].find("first", theConditions);																				if (tempRecord != undefined) {																						tempArray.push(tempRecord);																					}																				}																		}																			for (j = 0; j < _hasMany.length; j++) {																		if (including[i] == _hasMany[j]) {																				tempArray = tempArray.concat(_hasMany[j].find("all", theConditions));																			}																	}															}													}												if (tempArray.length > 1) {														return tempArray;														} else {														return tempArray[0];													}																	} else {													return false;												}								});							}								}				/**		 * Sorts the Records in this model and changes the id's accordingly.		 * @param theCompareFunction An optional reference to a compare function.		 * See the Array.sort method in the Flash docs for details. If no functino is given	 	 * the default is to sort alphabetically by the first column		 * @see public function sortItemsBy():void		 */		public function sortItems(theCompareFunc:Function = null):void {						var compareFunc:Function;						if (theCompareFunc != null) {								compareFunc = theCompareFunc;							} else {								compareFunc = sortCompare;							}						var tempIndex:int = doSort(itemsList, compareFunc);						this.dispatchEvent(new DataChangeEvent(DataChangeEvent.DATA_CHANGE, "sort", itemsList, 0, itemsList.length-1));					}				/**		 * Sorts the Records in this model according to a column and changes the id's accordingly.		 * @param fieldName The name of the column to sor by.		 * @see public function sortItems():void		 */		public function sortItemsBy(fieldName:String):void {						var tempIndex:int = doSort(itemsList, sortCompare,fieldName);						this.dispatchEvent(new DataChangeEvent(DataChangeEvent.DATA_CHANGE, "sort", itemsList, 0, itemsList.length-1 ));					}				/**		 * Removes all record items from the Model.		 * @see public function remove(theIndex:int):void		 */		public function removeAll():void {						var tempArray:Array = new Array();						var tempIndex:int = itemsList.length-1;								each(function (item:*):* {												tempArray.push(item.id);								item.destroy();							});						itemsList = [];						this.dispatchEvent(new DataChangeEvent(DataChangeEvent.DATA_CHANGE, "removeAll" , itemsList, 0, 0));					}				/**		 * Alias for the remove() method. Removes a record item at the specified index.		 * @param theIndex The index (zero indexed) of the item to be removed		 * @see public function removeAll():void		 */		public function removeItemAt(theIndex:int):void {						remove(theIndex);					}				/**		 * Removes a record item at the specified index.		 * @param theIndex The index (zero indexed) of the item to be removed		 * @see public function removeAll():void		 */		public function remove(theIndex:int):void {						this.dispatchEvent(new DataChangeEvent(DataChangeEvent.DATA_CHANGE, "remove", [itemsList[theIndex]], theIndex, theIndex));						itemsList[theIndex].destroy();						itemsList.splice(theIndex,1);			titlesList.splice(theIndex,1);					}				/**		 * Replaces a record item at the specified index.		 * @param theIndex The index (zero indexed) of the item to be replaced		 * @param theItem A JSDataRecord that will replace the old one		 */		public function replaceItemAt(theIndex:int, theItem:JSDataRecord):void {						removeItemAt(theIndex);			  			addItemAt(theIndex, theItem);					}							/**		 * Updates a record item at the specified index.		 * @param theIndex The index (zero indexed) of the item to be updated		 * @param theAttributes The name-value pairs for the updated item. Takes the form 		 * {columnName1:value1, columnName2:value2, ... }		 * @see public function updateAll(theAttributes:Object, theConditions:Object)		 */		public function update(theIndex:int, theAttributes:Object):void {						itemsList[theIndex].update(theAttributes);					}				/**		 * Updates an attribute of a record item at the specified index.		 * @param theIndex The index (zero indexed) of the item to be updated		 * @param theFieldName The attribute (column) name for the field to update		 * @param newData The new data for the record attribute		 */		public function editField(theIndex:int, theFieldName:String, newData:*):void {						itemsList[theIndex][theFieldName] = newData;					}				/**		 * Updates all record items.		 * @param theAttributes The name-value pairs for the updated item. Takes the form 		 * {columnName1:value1, columnName2:value2, ... }		 * @param theConditions The optional conditions that determine which items to update.		 * theConditions takes the form {name1:value1, name2:value2, ... }. In plain english this conducts a 		 * search where the column "name1" has the value "value1" and the column "name2" has the value "value2"		 * @see public function updateAll(theAttributes:Object, theConditions:Object)		 */		public function updateAll(theAttributes:Object, theConditions:Object):void {						var tempArray:Array = this.find("all", theConditions);						for (var i:int = 0; i < tempArray.length; i++) {								tempArray[i].update(theAttributes);							}						this.dispatchEvent(new DataChangeEvent(DataChangeEvent.DATA_CHANGE, "change", tempArray, 0, itemsList.length-1));					}				/**		 * Returns the contents of this model in XML form.		 * @return an XML object containing the contents of the model.		 */		public function toXML():XML {						var returnXML:XML;						XML.ignoreWhitespace = true;						// Do a simple pluriflication.			returnXML = <{String(_modelName+"s")}></{String(_modelName+"s")}>;						returnXML.@type = "array"						each(function (item:*):* {								var newItem:XML = item.toXML();				newItem.setLocalName(_modelName);								returnXML.appendChild(newItem);							});						return returnXML;					}				/**		 * Returns the a String description of this model.		 * @return a String.		 */		override public function toString():String		{						return "[object JSDataModel]";					}				/**		 * Returns an Object representation of this object with the JSDataRecord id's as attribute names and 		 * object representations of the JSDataRecord as values. Uses JSDataRecord.toObject() to convert the records		 * to Objects.		 * @return Returns an Object representation of this object		 */		public function toObject():Object		{						var tempObj:Object = new Object();						each(function (item:*):* {									tempObj[item.id] = item.toObject();							});						return tempObj;					}				/**		 * Returns an Array representation of this object with object representations of the JSDataRecord as values.		 * Uses JSDataRecord.toObject() to convert the records.		 * @return Returns an Array representation of this object		 */		override public function toArray():Array {						var tempArr:Array = new Array();						each(function (item:*):* {								tempArr.push(item.toObject());							});						return tempArr;					}				////////////////////////////////////////////////////////////////////////////		//		// Private Methods		//		////////////////////////////////////////////////////////////////////////////				/**		 * The doEach() implementation that will be used for all enumerable operations		 *	@param iterator A function that will be called once per iteration with the		 *	JSDataRecord as the argument		 *	@see com.jsjstudios.jumpship.core.JSEnumerable		 */		protected override function doEach(iterator:Function):* {						for (var i:int = 0; i < itemsList.length; i++) {								iterator(itemsList[i]);						}				}				/**		 * This functions sorts an array of items according to a compare function and an optional		 *	fieldName on which to perform the sort.		 *	@param theItems		 *	@param compareFunction		 *	@param fieldName		 *	@return the index of the first item in the array that was affected.		 */		protected function doSort(theItems:Array, compareFunc:Function, fieldName:String = null):int {						var tempIndex:int						for (var i:int = 0; i < theItems.length; i++) {								for (var j:int = 0; j < theItems.length; j++) {										if (i > j ) {												if ( compareFunc(theItems[i], theItems[j], fieldName) == -1) {													if (tempIndex == 0) {																tempIndex = i;															}																			   							var tempItem1:JSDataRecord = theItems[i];							var tempItem2:JSDataRecord = theItems[j];														theItems[i] = tempItem2;							theItems[j] = tempItem1;													}											}									}							}						// Retun the index of the first item affected.			return tempIndex;					}				/**		 * The default sort compare function compares two records		 */		protected function sortCompare(a:JSDataRecord,b:JSDataRecord, fieldName:String = null):int {						// By default this function compares the first column			if (fieldName == null) {								fieldName = titlesList[0];							}						if (typeof(a[fieldName]) == "number") {								if (a[fieldName] < b[fieldName]) {										return -1;									} else if (a[fieldName] > b[fieldName]) {										return 1;									}							} else {								if (a[fieldName].toUpperCase() < b[fieldName].toUpperCase()) {										return -1;									} else if (a[fieldName].toUpperCase() > b[fieldName].toUpperCase()) {										return 1;									}							}						return 0;					}				////////////////////////////////////////////////////////////////////////////		//		// Event Handlers		//		////////////////////////////////////////////////////////////////////////////			/**		 *	A handler for a data binding event thrown by one of the child items.		 *	this function issues a DataChangeEvent.		 *	@param eventObj		 */		protected function dataRecordBindingEvent(eventObj:Object):void {						var theRecord:JSDataRecord = eventObj.record;			var theName:String = eventObj.attribute;						var tempIndex:int = 0;						each(function (item:*, i:int):* {												if (item == theRecord) {										tempIndex = i;									}							});						dispatchEvent(new DataChangeEvent(DataChangeEvent.DATA_CHANGE, "record", [theRecord], tempIndex, tempIndex));					}			////////////////////////////////////////////////////////////////////////////		//		// Getter/Setters		//		////////////////////////////////////////////////////////////////////////////			/**		 * An array containing the names of the columns in this Model		 */		[Bindable]		public function get columnNames():Array {			return titlesList;		}		public function set columnNames(theNames:Array):void {						if (theNames == null) {				theNames = [];			}						titlesList = theNames;						// Make sure the item has all of the columns in this model			for (var i:int = 0; i < titlesList.length; i++) {								each(function (item:*):* {													if (item[titlesList[i]] == undefined) {												item.addAttribute(titlesList[i]);											}									});							}					}				/**		 * (Read Only) The number of record items in this Model		 */		public function get length():int {			return itemsList.length;		}				/**		 * (Read Only) An array of all record items in this Model. Same as records property.		 */		public function get items():Array {			return itemsList;		}				/**		 * (Read Only) An array of all record items in this Model. Same as items property.		 */		public function get records():Array {			return itemsList;		}				/**		 * An array referencing other Models that this Model has a "has one" relationship		 * to.		 * @see hasMany		 */		[Bindable]		public function get hasOne():Array {			return _hasOne;		}		public function set hasOne(theArray:Array):void {			_hasOne = theArray;		}				/**		 * An array referencing other Models that this Model has a "has many" relationship		 * to.		 * @see hasOne		 */		[Bindable]		public function get hasMany():Array {			return _hasMany;		}		public function set hasMany(theArray:Array):void {			_hasMany = theArray;		}				/**		 * A String defining the name of this model. When using this model with a server-side		 * gateway (like JSRailsGateway), this name should be the table name that this model represents.		 */		[Bindable]		public function get modelName():String {			return _modelName;		}		public function set modelName(theName:String):void {			_modelName = theName;		}					}	// Class End	} // Package End