//////////////////////////////////////////////////////////////////////////////////// JumpShip Framework for AS3// Copyright 2008 Jamie Scanlon//// Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the "Software"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS // IN THE SOFTWARE.//// Project: JumpShip Framework - Rails Gateway// File: JSRailsGateway.as// Created by: Jamie Scanlon//////////////////////////////////////////////////////////////////////////////////package com.jsjstudios.jumpship.rails {	////////////////////////////////////////////////////////////////////////////////	// Imports	////////////////////////////////////////////////////////////////////////////////		import com.jsjstudios.jumpship.core.JSDataModel;	import com.jsjstudios.jumpship.core.JSDataRecord;	import com.jsjstudios.jumpship.rails.events.RailsGatewayEvent;		import flash.events.*;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.net.URLRequestMethod;		////////////////////////////////////////////////////////////////////////////////	// Compiler Meta	////////////////////////////////////////////////////////////////////////////////	/**	*	@eventType com.jsjstudios.jumpship.rails.events.RailsGatewayEvent.MESSAGE_RECEIVED	*/	[Event(name="messageReceived", type="com.jsjstudios.jumpship.rails.events.RailsGatewayEvent")]		/**	*	@eventType com.jsjstudios.jumpship.rails.events.RailsGatewayEvent.DATA_RECEIVED	*/	[Event(name="dataReceived", type="com.jsjstudios.jumpship.rails.events.RailsGatewayEvent")]		////////////////////////////////////////////////////////////////////////////////	//	// Class: JSRailsGateway	//	////////////////////////////////////////////////////////////////////////////////	/** 	 * JumpShip Rails Gateway Base Class. This class is the base class for a standard implementation	 * of a Flash / Ruby on Rails gateway. This class communicates with a RESTful Rails controller.	 * A RESTful Rails Controller maps URL's and request methods (GET, POST, DELETE, PUT) into methods	 * such as index, show, create, update, destroy. This class provides the basic Create Read Update Delete 	 * (CRUD) operations for communicating with a Ruby on Rails backend.	 * This Class traslates server-side data into JSDataModel Objects.	 */	public class JSRailsGatewayBase extends EventDispatcher	{				//		// Properties		//		/**		*	@private			*/		protected var _baseURL:String;				/**		*	@private			*/		protected var _service:Object;				/**		*	@private			*/		protected var _model:JSDataModel;				/**		*	@private			*/		protected var _enableMessaging:Boolean;			//		// Assets		//				/**		*	An array of column names that are to be used with any data that		*	is returned from the server.		*/		protected var modelColumnNames:Array;				/**		*	The raw XML message that is returned from the server			*/		protected var messageXML:XML;				/**		*	The URLRequest instance used for communication with the server		*/		protected var xmlURL:URLRequest;				/**		*	The URLLoader instance used for communication with the server			*/		protected var xmlLoader:URLLoader;				/**		*	An Object of parameters retuned from a server message		*/		protected var resultParams:Object;				/**		*	A JSDataModel that contains data returned from the server.		*/		protected var resultModel:JSDataModel;					////////////////////////////////////////////////////////////////////////////////		//		// Constructor		//		////////////////////////////////////////////////////////////////////////////////		/**		*	Constructor			*	@param theService An Object that supplies the base url for all service calls. 		*	The base url is retrieved by calling <code>toString()</code> on theService.		*/		function JSRailsGatewayBase ( theService:Object )		{						resultParams = new Object();			resultModel = new JSDataModel();						messageXML = new XML();			XML.ignoreWhitespace = true;			XML.prettyPrinting = false;						_enableMessaging = true;						xmlURL = new URLRequest();			xmlLoader = new URLLoader();			xmlLoader.addEventListener("complete", railsReplyEvent);			xmlLoader.addEventListener("httpStatus", railsReplyEvent);			xmlLoader.addEventListener("ioError", railsReplyEvent);			xmlLoader.addEventListener("progress", railsReplyEvent);			xmlLoader.addEventListener("securityError", railsReplyEvent);			xmlLoader.addEventListener("open", railsReplyEvent);						service = theService as Object;						xmlURL.contentType = "application/xml";			xmlURL.method = URLRequestMethod.GET;					}				////////////////////////////////////////////////////////////////////////////////		//		// Public Methods		//		////////////////////////////////////////////////////////////////////////////////				/**		 * Requests data from the Rails model		 * The model to interact with is determined by the <code>model.modelName</code> property.		 * 		 * @param theParams An optional <code>Object</code> that defines parameters for retrieving		 * data. <code>theParams.method</code> can be set to "list" or "show". "list" returns all		 * records in the database while "show" selects one. <code>theParams.method</code> defaults		 * to "list". <code>theParams.id</code> is used with the "show" method to determine what		 * record to return. <code>theParams.id</code> defaults to 1.		 */		public function dataRequest(theParams:Object = null):void {						//			// This function requests a raw data from a particular 'model'			// (usually corresponting to a DB table) given some conditions.			// The server should querey the data and return it as xml.			//						var theMethod:String; // e.g. "list" or "show"			var theID:Number; // Rails id						if (theParams != null ) {				theMethod = theParams.method;				theID = Number(theParams.id);			}						if (isNaN(theID) || theID < 1) {				theID = 1;			}						if (theMethod == null) {				theMethod = "list";			}						// It is important that the model names match with what Rails expects.			// Rails needs a plural model name in the url.			// Inflector ( thank you Derek Wischusen ) is a port of the Rails Inflector			// class so the names should match up.			var useName:String = Inflector.pluralize(model.modelName);						switch (theMethod) {								case "list":					// format like: http://localhost:3000/users.xml					URLRequest(xmlURL).url = String(baseURL+"/"+useName+".xml");					break;				case "show":					// format like: http://localhost:3000/users/1.xml					URLRequest(xmlURL).url = String(baseURL+"/"+useName+"/"+theID+".xml");					break;				default:					break;								}						trace (String("JSRailsGatewayBase: Sending: "+xmlURL.url))						xmlURL.method = URLRequestMethod.GET						load();					}				/**		 * Sends data to the Rails model		 * The model to interact with is determined by the <code>model.modelName</code> property.		 * 		 * @param theParams An optional <code>Object</code> where <code>theParams.record</code> contains		 * the new record to save. While <code>theParams</code> is optional, this method doesn't do		 * anything unless it is defined. The reason for the object to be optional is because this method		 *	will most likely be overridden in subclasses to perform according to a specific service		 *	architecture and is intended to be very flexible to accommodate this.		 */		public function dataSubmit(theParams:Object = null):void {						//			// This function submits raw data to a particular 'model'			// (corresponting to a DB table).			//						if (theParams == null) return;						// It is important that the model names match with what Rails expects.			// Rails needs a plural model name in the url.			// Inflector ( thank you Derek Wischusen ) is a port of the Rails Inflector			// class so the names should match up.			var useName:String = Inflector.pluralize(model.modelName);					messageXML = JSDataRecord(theParams.record).toXML();					messageXML.setLocalName(_model.modelName);						// Don't mess with the id			delete messageXML.id;						trace(String("JSRailsGatewayBase: Sending: "+messageXML));						xmlURL.data = messageXML;						// format like: http://localhost:3000/users.xml			xmlURL.url = String(baseURL+"/"+useName+".xml");						xmlURL.method = URLRequestMethod.POST						load();					}				/**		 * Updates a record in the Rails model		 * The model to interact with is determined by the <code>model.modelName</code> property.		 * 		 * @param theParams An optional <code>Object</code> where <code>theParams.record</code> contains		 * the record to update. While <code>theParams</code> is optional, this method doesn't do		 * anything unless it is defined. The reason for the object to be optional is because this method		 *	will most likely be overridden in subclasses to perform according to a specific service		 *	architecture and is intended to be very flexible to accommodate this.		 */		public function dataUpdate(theParams:Object = null):void {						//			// This function updates record(s) in a particular 'model'			// (corresponting to a DB table).			//						if (theParams == null) return;						// It is important that the model names match with what Rails expects.			// Rails needs a plural model name in the url.			// Inflector ( thank you Derek Wischusen ) is a port of the Rails Inflector			// class so the names should match up.			var useName:String = Inflector.pluralize(model.modelName);						messageXML = JSDataRecord(theParams.record).toXML();					messageXML.setLocalName(_model.modelName);						xmlURL.data = messageXML;						// format like: http://localhost:3000/users/1.xml?_method=put			xmlURL.url = String(baseURL+"/"+useName+"/"+JSDataRecord(theParams.record).id+".xml?_method=put");						trace(String("JSRailsGatewayBase: Sending: "+messageXML));						xmlURL.method = URLRequestMethod.POST						load();					}				/**		 * Deletes a record from the Rails model		 * The model to interact with is determined by the <code>model.modelName</code> property.		 * 		 * @param theParams An optional <code>Object</code> where <code>theParams.record</code> contains		 * the record to delete. While <code>theParams</code> is optional, this method doesn't do		 * anything unless it is defined. The reason for the object to be optional is because this method		 *	will most likely be overridden in subclasses to perform according to a specific service		 *	architecture and is intended to be very flexible to accommodate this.		 */		public function dataDelete(theParams:Object = null):void {						//			// This function deletes a record from a particular 'model'			// given some conditions.			//						if (theParams == null) return;						// It is important that the model names match with what Rails expects.			// Rails needs a plural model name in the url.			// Inflector ( thank you Derek Wischusen ) is a port of the Rails Inflector			// class so the names should match up.			var useName:String = Inflector.pluralize(model.modelName);						messageXML = JSDataRecord(theParams.record).toXML();					messageXML.setLocalName(_model.modelName);						xmlURL.data = messageXML;						// format like: http://localhost:3000/users/1.xml?_method=delete			xmlURL.url = String(baseURL+"/"+useName+"/"+JSDataRecord(theParams.record).id+".xml?_method=delete");						trace(String("JSRailsGatewayBase: Sending: "+messageXML));						xmlURL.method = URLRequestMethod.POST						load();					}					////////////////////////////////////////////////////////////////////////////////		//		// Private Functions		//		////////////////////////////////////////////////////////////////////////////////				/**		*	@private		*	Initiates communication with the Rails server.		*/		protected function load():void {						try{				xmlLoader.load(xmlURL);			} catch (error:Error) {				// URLLoader Error				messageXML = <message success='false'><failure_cause>Unable to connect.</failure_cause></message>;				processResult(messageXML);			}					}				/**		*	@private		*	A method for parsing the XML result received from the Rails server.		*	The result can contain data or a simple message containing arbitrary		*	parameters. If the message has a 'success' attribute that is set to 'false'		*	the message is trated as an error message.		*/		protected function processResult(theXML:XML):void {						//			// There are two types of responses that the gateway can receive.			//			// Message:			// <message success='true'><param/></message>			//			// This is a message that is passed from the server with success/failure			// status and possibly some parameters. A missing 'success' attribute is			// the same as success='true'			//			// Data:			// <models type="array">			//   <model>			//     <fieldName>value</fieldName>			//     <fieldName>value</fieldName>			//   </model>			//   <model>			//     <fieldName>value</fieldName>			//     <fieldName>value</fieldName>			//   </model>			// </models>			//			// This is raw data being sent back from the server.			// Note: the node names will depend on the model names and fields			//										//			// ON an failed result			//			if (theXML.@success == "false") {								trace("WARNING: JSRailsGatewayBase returned a failed result: "+theXML.children()[0].children()[0]);								resultParams = {};				resultParams = {success:"false"}								for (var j:int = 0; j < theXML.children().length();j++) {										resultParams[theXML.children()[j].name.localName] = theXML.children()[j].children()[0];										}								tempEvent = new RailsGatewayEvent(  RailsGatewayEvent.MESSAGE_RECEIVED, this, resultParams);				dispatchEvent(tempEvent);											//			// ON an sucessful result			//			} else {								var i:int;				var tempEvent:RailsGatewayEvent;								if (enableMessaging && theXML.localName() == "message") {									resultParams = {};					resultParams = {success:theXML.@success}										for (i = 0; i < theXML.children().length();i++) {												resultParams[theXML.children()[i].name()] = theXML.children()[i].children()[0];												}										tempEvent = new RailsGatewayEvent(RailsGatewayEvent.MESSAGE_RECEIVED, this, resultParams);					dispatchEvent(tempEvent);									} else {										resultModel.removeAll();										var pluralName:String = Inflector.pluralize(model.modelName);										if (theXML.localName() == pluralName) {												if (modelColumnNames == null) {							modelColumnNames = getFieldNames(theXML.children()[0]);						}												resultModel.columnNames = modelColumnNames;											for (i = 0; i < theXML.children().length();i++) {							resultModel.addItem(parseRecord(theXML.children()[i]))						}										} else if (theXML.localName() == model.modelName) {												if (modelColumnNames == null) {							modelColumnNames = getFieldNames(theXML);						}												resultModel.columnNames = modelColumnNames;											resultModel.addItem(parseRecord(theXML))											}										tempEvent = new RailsGatewayEvent(RailsGatewayEvent.DATA_RECEIVED, this, resultModel);					dispatchEvent(tempEvent);									}							}					}				/**		*	@private		*	A utility method for creating a JSDataRecord from XML returned		*	from the Rails server.		*	@see com.jsjstudios.jumpship.core.JSDataRecord		*/		protected function parseRecord(theXML:XML):JSDataRecord {						var tempRecord:JSDataRecord = new JSDataRecord();			var tempObj:Object = {};						for (var j:int = 0; j < theXML.children().length(); j++) {								tempObj[theXML.children()[j].localName()] = theXML.children()[j].children()[0];							}						tempRecord.create(tempObj);			return tempRecord;							}				/**		*	@private		*	A utility method for returning an array of field names from the XML		*	produced by JSDataRecord.toXML()		*	@see com.jsjstudios.jumpship.core.JSDataRecord		*/		protected function getFieldNames(theRecordXML:XML):Array {						var tempFields:Array = new Array();						for (var k:int = 0; k < theRecordXML.children().length(); k++) {								tempFields.push(theRecordXML.children()[k].localName());							}									return tempFields;							}				////////////////////////////////////////////////////////////////////////////////		//		// Event Handlers		//		////////////////////////////////////////////////////////////////////////////////				/**		*	@private		*	This method recieves status all events from URLLoader as a result of		*	communication with the server. In the default implementation 'httpStatus',		*	'open', and 'progress' events are ignored.		*	@param eventObj		*	@see flash.net.URLLoader		*/		protected function railsReplyEvent(eventObj:Object):void {						switch (eventObj.type) {								case "complete":									messageXML = XML(xmlLoader.data)					processResult(messageXML);										break;				case "httpStatus":					break;				case "ioError":										messageXML = <message success='false'><failure_cause>Unable to connect. IO Error</failure_cause></message>;					processResult(messageXML);									break;				case "progress":					break;				case "securityError":										messageXML = <message success='false'><failure_cause>Unable to connect. Security Error</failure_cause></message>;					processResult(messageXML);									break;				case "open":					break;				default:					break;							}						}				////////////////////////////////////////////////////////////////////////////////		//		// Getters/Setters		//		////////////////////////////////////////////////////////////////////////////////				/**		 * A String containing the base URL of the Rails application.		 */		[Bindable]		public function get baseURL():String {			return _baseURL;		}		public function set baseURL(theURL:String):void {			_baseURL = theURL;		}				/**		*	A service object that is used to determine the base path of the server			*/		[Bindable]		public function get service():Object {			return _service as Object;		}		public function set service(theService:Object):void {			_service = theService;			if ( theService.hasOwnProperty('url') ) {				_baseURL = theService['url'];			} else {				_baseURL = theService.toString();			}		}				/**		 * A JSDataMode that's linked to this gateway. This property is particularly important		 * in determining which Rails model to talk to on the server. <code>model.modelName</code>		 * needs to have the same name as the Rails model it is communicating with.		 * The <code>model.modelName</code> should always be in the singular and should be lower case.		 */		[Bindable]		public function get model():JSDataModel {			return _model;		}		public function set model(theModel:JSDataModel):void {			_model = theModel;		}				/**		 * A Boolean indicating whether this gateway treats XML it recieves with a root node named		 * 'message' ( <message>...</message> ) as a message rather than data. Messages trigger a		 * <code>RailsGatewayEvent.MESSAGE_RECEIVED</code> event and the contents of the XML is		 * placed in an <code>Object</code> rather than a <code>JSDataModel</code>. Messaging can		 * be dissabled on the occasion where you might have a Rails model called 'message' and		 * you would like the contents of the model to be treated as normal data. This property is		 * set to true by default.		 */		[Bindable]		public function get enableMessaging():Boolean {			return _enableMessaging;		}		public function set enableMessaging(theFlag:Boolean):void {			_enableMessaging = theFlag;		}			}  // Class End	} // Package End