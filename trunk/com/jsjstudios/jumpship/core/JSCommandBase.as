//////////////////////////////////////////////////////////////////////////////////// JumpShip Framework for AS3// Copyright 2008 Jamie Scanlon//// Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the "Software"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS // IN THE SOFTWARE.//// Project: JumpShip Framework - Core// File: JSCommandBase.as// Created by: Jamie Scanlon//////////////////////////////////////////////////////////////////////////////////package com.jsjstudios.jumpship.core{	////////////////////////////////////////////////////////////////////////////////	// Imports	////////////////////////////////////////////////////////////////////////////////	import com.jsjstudios.jumpship.core.JSRuntimeEnvironment;	import com.jsjstudios.jumpship.interfaces.ICommand;	////////////////////////////////////////////////////////////////////////////////	//	//	// Class: JSCommandBase	//	//	////////////////////////////////////////////////////////////////////////////////	/**	 * <code>Command</code> Base Class. In this framework commands have the ability to cascade or	 * call other commands. Therefore this base class contains a lot of the same	 * methods as the Controller base class. But whereas the Controller MUST implement	 * primitive command functions, commands are not required to.	 */	public class JSCommandBase implements ICommand	{		//		// Properties		//		/**		 *	@private		 */		private var _returnFunc:Function;		// The return function				/**		 *	The parameters passed in to the command		 */		protected var parameters:Object;				/**			 *	The returned result of the command		 */		protected var resultObject:Object;				/**		 *	holds named list of commands		 */		protected var commands:Object;				/**		 *	history of commands		 */		protected var commandHistory:Array;			////////////////////////////////////////////////////////////////////////////		//		// Constructor		//		////////////////////////////////////////////////////////////////////////////				/**		 *	Constructor		 */		public function JSCommandBase ()		{						// Initialize Properties			commands = new Object();			commandHistory = new Array();						// Hook Functions			preCommandInit();			addCommands();			init();					}			////////////////////////////////////////////////////////////////////////////		//		// Primitive Functions		//		////////////////////////////////////////////////////////////////////////////				/**		 * The main execution block for a <code>JSCommandBase</code>.		 * <p>		 * This primitive method is called by the execute() method. After doing it's work		 * (asynchonously or not), the <code>onResultOperation()</code> method must get called		 * with the result of the operation (even if null). Doing so completes the loop of		 * creating a command and returning a result and since commands are logged in JumpShip,		 * it ensures this command does not stay in memory after it has completed it's task.		 */		public function executeOperation ():void		{						onResultOperation ( null );					}			/**		 * The main result processing block for a <code>JSCommandBase</code>.		 * <p>		 * This method must be called when this command has completed it's operations. It must 		 * also call <code>onResult(theResult)</code> to notify the owner that this command has completed.		 * 		 * @param theResult an <code>Object</code> containing the result of the operation (if any).		 */		public function onResultOperation ( theResult:Object = null ):void		{						this.onResult (theResult);					}				/**		 * An optional status handler <code>JSCommandBase</code>.		 * <p>		 * This method can be implemented by extending classes and gets called by the <code>onStatus()</code>		 * event handler.		 * 		 * @param theStatus an <code>Object</code> containing the status of the operation (if any).		 */		public function onStatusOperation ( theStatus:Object = null ):void {}			////////////////////////////////////////////////////////////////////////////		//		// Hook Functions		//		////////////////////////////////////////////////////////////////////////////				/**		 *	A method that is called before any Commands have been initialized		 */		protected function preCommandInit():void{}				/**		 *	A method that is called after any Commands have been initialized.		 *	This method should be overriden to perform basic class initialization.		 */		protected function init():void{}				/**		 *	A method that is called before any child Command is called.		 *	This method can be overriden to perform pre-commnad filtering logic.		 *	@param theCommandName The name of the command that will be called 		 *	directly after this method ends.		 */		protected function beforeFilter(theCommandName:String):void{}				/**		 *	A method that is called after any Command is called.		 *	This method can be overriden to perform post-commnd filtering logic.		 *	@param theCommandName The name of the command that has just finished executing.		 */		protected function afterFilter(theCommandName:String):void{}				/**		 *	A method that is called to add child Commands that this Command can call in the		 *	course of its duty's. The format for adding a Command should be as follows:		 *	<p>		 *	<code>addCommand ( "getPersonListCommand", GetPersonListCommand );</code>		 *	<p>		 *	"getPersonListCommand" is the name of the command that will returned with the		 *	result of the child Command.		 */		protected function addCommands ():void		{			//			// Note: Commands are added as references to the classes. Dispatching 			// a command includes creating an instance of it, which is then kept			// in a history log on the controller. The command is automatically 			// removed after the service has returned (so we don't have a memory leak).			//			// The general format should be:			//			// addCommand ( "getPersonListCommand", GetPersonListCommand );		}				/**		 *	A method that child Commands use to return their results to this Command.		 *	@param theResultObject An object containing the result of the child Command.		 *	This object will be in the form:<br>		 *	<code>theResultObject.type : String</code> - the name of the command returning the result<br>		 *	<code>theResultObject.result : Object</code> - the result object.<br>		 */		protected function processCommandResult(theResultObject:Object):void		{						// theResultObject will be in the form:			// theResultObject.type : String - the name of the command returning the result			// theResultObject.result : Object - the actual result					}				////////////////////////////////////////////////////////////////////////////		//		// Public Methods		//		////////////////////////////////////////////////////////////////////////////			/**		 * Executes the <code>JSCommandBase</code>. 		 * <p>		 * This implementation of <code>ICommand</code> is purposefully strict, requiring the <code>returnFunc</code>		 * and <code>params</code> arguments to be present. This method is final and calls the onExecuteOperation() method 		 * to carry out the main functionality.		 * 		 * @param params an <code>Object</code> containing variables this Command may use to carry out it's task.		 * @param returnFunc an <code>Function</code> that get's called once the Command has completed.		 * @param token an optional <code>Object</code> passed back through the argument of the <code>returnFunc</code>.		 * @see com.jsjstudios.jumpship.interfaces ICommand		 * @see public function executeOperation ()		 * @throws <code>Error</code> If either <code>params</code> or <code>returnFunc</code> is null.		 */		final public function execute (params:Object = null, returnFunc:Function = null, token:Object = null):void		{				resultObject = new Object();			resultObject.id = token;						if (returnFunc != null) {								_returnFunc = returnFunc;							} else {								if (JSRuntimeEnvironment.getInstance().environment == "development") {										throw new Error ("ERROR Command "+COMMANDNAME+" did not receive the proper parameters upon instantiation. The returnFunc was not given or is undefined.");									}							}						if (params != null) {								parameters = params;							} else {								if (JSRuntimeEnvironment.getInstance().environment == "development") {										throw new Error ("ERROR Command "+COMMANDNAME+" did not receive the proper parameters upon instantiation. The parameters object was not given or is undefined.");									}							}						if (params != null && returnFunc != null) {								executeOperation();							}		}				/**		 * Processes the result of a <code>JSCommandBase</code> instance. 		 * <p>		 * This is the default <code>returnFunc</code> given to a new <code>JSCommandBase</code>.		 * This method calls the afterFilter() hook method. This method then calls the 		 * processCommandResult primitive method with the result.		 * @param theResultObject An object containing the result information from the command.		 */		final public function returnCommandResult(theResultObject:Object):void		{						afterFilter(theResultObject.type);						processCommandResult(theResultObject); 					}				////////////////////////////////////////////////////////////////////////////		//		// Private Functions		//		////////////////////////////////////////////////////////////////////////////				/**		 *	A method for adding child Commands.		 *	@param commandName The name of the Command.		 *	@param commandRef A reference to the Command Class.		 */		protected function addCommand ( commandName:String, commandRef:Class ):void		{						if ( commands [ commandName ] != undefined ) {								if (JSRuntimeEnvironment.getInstance().environment == "development") {										throw new Error ("ERROR The command "+commandName+" has already been added to the Controller.");									}							} else {								commands [ commandName ] = commandRef;							}		}				/**		 *	A method for creating and executing a child Commands.		 *	@param theNotification The name of the Command as given in <code>addCommand()</code>.		 *	@param theParams An object that will be passed to the Command that can contain parameters.		 */		protected function createCommand(theNotification:String, theParams:Object):void		{						beforeFilter(theNotification)						var newCommand:ICommand = new commands [ theNotification ]()			commandHistory.push({name:theNotification, params:theParams});						// to prevent a memory leak, limit the size of the array to MAXHISTORY			while (commandHistory.length > MAXHISTORY) {				commandHistory.splice(0,1);			}						// One simplification in the way Commands execute other Commands and the way			// Controllers execute Commands is that Commands always give the same return			// function, returnCommandResult()			newCommand.execute(theParams, returnCommandResult);						}			////////////////////////////////////////////////////////////////////////////		//		// Event Handlers		//		////////////////////////////////////////////////////////////////////////////			/**		 * Process the <code>JSCommandBase</code> status.		 * <p>		 * It is anticipated that Commands may call services, in which case this is the		 * event handler for a Status message. This handler calls the onStatusOperation() Hook Function.		 * @param statusObj An Object comtaning the event parameters.		 */		final public function onStatus ( statusObj:Object = null ):void		{			onStatusOperation( statusObj );		}				/**		 * Process the <code>JSCommandBase</code> result.		 * <p>		 * This handler packages the resultObj into a wrapper Object in the form 		 * {type:COMMANDNAME, result:resultObj, id:token} (where token is the <code>token</code> that		 * was passed into the <code>execute()</code> function), and sends the result to the <code>returnFunc</code>.		 * @param resultObj An Object containing the event parameters.		 */		final public function onResult ( resultObj:Object = null ):void			{			// Identify the command being returned. the parameters.__id is			// a token that is handed back to the calling controller.			resultObject.type = COMMANDNAME;							// The onResult Handler can receive no parameters in which case 			// resultObject.result will be null			resultObject.result = resultObj;						_returnFunc(resultObject);					}				////////////////////////////////////////////////////////////////////////////		// Pseudo Constants - 		// These constants are implemented as getters so that exending classes		// can override the default values.		////////////////////////////////////////////////////////////////////////////				/**		 * Pseudo Constant: The Name Of thie Command. This constant should be overwritten by 		 * extending classes.		 */		public function get COMMANDNAME():String {						return "JSCommandBase";					}				/**		 * Pseudo Constant: Determines the maximum number of commands this command will remember		 * in it's history.		 */		public function get MAXHISTORY():uint {						return 100;					}			} // Class End	} // Package End