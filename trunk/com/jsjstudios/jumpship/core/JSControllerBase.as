//////////////////////////////////////////////////////////////////////////////////// JumpShip Framework for AS3// Copyright 2008 Jamie Scanlon//// Permission is hereby granted, free of charge, to any person obtaining a copy // of this software and associated documentation files (the "Software"), to deal // in the Software without restriction, including without limitation the rights // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell // copies of the Software, and to permit persons to whom the Software is // furnished to do so, subject to the following conditions://// The above copyright notice and this permission notice shall be included in all // copies or substantial portions of the Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS // IN THE SOFTWARE.//// Project: JumpShip Framework - Core// File: JSControllerBase.as// Created by: Jamie Scanlon//////////////////////////////////////////////////////////////////////////////////package com.jsjstudios.jumpship.core{	////////////////////////////////////////////////////////////////////////////////	// Imports	////////////////////////////////////////////////////////////////////////////////		import com.jsjstudios.jumpship.interfaces.IController;	import com.jsjstudios.jumpship.interfaces.ICommand;	import com.jsjstudios.jumpship.core.JSRuntimeEnvironment;	import flash.events.EventDispatcher;	import flash.events.Event;		////////////////////////////////////////////////////////////////////////////////	//	//	// Class: JSControllerBase	//	//	////////////////////////////////////////////////////////////////////////////////		/**	* Controller Base Class.	*/	public class JSControllerBase extends EventDispatcher implements IController	{		//		// Assets		//		/**		 *	@private		 */										protected var commands:Object;			// holds named list of commands				/**		 *	log of called commands		 */		protected var commandLog:Array;				/**		 *	history of called commands		 */		protected var commandHistory:Array;				////////////////////////////////////////////////////////////////////////////		//		// Constructor		//		////////////////////////////////////////////////////////////////////////////		/**		 *	Constructor		 */		public function JSControllerBase () 		{						// Initialize Properties			commands = new Object();			commandLog = new Array();			commandHistory = new Array();						// Hook Functions			preCommandInit();			addCommands();			init();					}				////////////////////////////////////////////////////////////////////////////		//		// Public Methods 		//		////////////////////////////////////////////////////////////////////////////				/**		 * Register a particular <code>ICommand</code> with a notifier.		 * 		 * @param notification a <code>String</code> parameter		 * @param commandRef the Class of the <code>ICommand</code>		 * @throws <code>Error</code> If the notification was previously associated with a command		 */		final public function addCommand ( notification:String, commandRef:Class):void		{						if ( commands [ notification ] != undefined ) {								if (JSRuntimeEnvironment.getInstance().environment == "development") {										throw new Error ("ERROR The command notification "+notification+" has already been added to the Controller.");									}							} else {				commands [ notification ] = commandRef;			}					}				/**		 * Creates and executes the <code>ICommand</code> that is referenced by the notification. 		 * 		 * @see com.jsjstudios.jumpship.interfaces ICommand		 * @see public function executeOperation ()		 * @throws <code>Error</code> If this function is not imlemented by the extending class		 */		final public function createCommand( notification:String, theParams:Object = null, theReturnFunc:Function = null ):void		{						if (commands[notification] == undefined) {				if (JSRuntimeEnvironment.getInstance().environment == "development") {						throw new Error ("ERROR The command notification "+notification+" has already been added to the Controller.");				}							}							// Create a unique id for this command			var tempDate:Date = new Date();			var idNum:Number = Date.UTC(tempDate.getFullYear(),tempDate.getMonth(), tempDate.getDate(), tempDate.getHours(), tempDate.getMinutes(), tempDate.getSeconds(), tempDate.getMilliseconds());			var idString:String = String(idNum);						// Check to see if this id already exists			while (commandLog[idString] != undefined) {								// if so increment the id number				idNum++;				idString = String(idNum);							}						beforeFilter(notification);						// Add the command to the history			commandHistory.push({name:notification, params:theParams, returnFunc:theReturnFunc});						// to prevent a memory leak, limit the size of the array to MAXHISTORY			while (commandHistory.length > MAXHISTORY) {					commandHistory.splice(0,1);			}						// There is a little bait and switch here... this method can accept any function as a			// return function but instead of passing this function to the command, it passes it's			// own return function it order to implement the afterFilter() method. The real return			// function is saved and called later.			commandLog[idString] = new Object();			commandLog[idString].returnFunc = theReturnFunc;						var newCommand:ICommand = new commands [ notification ]();			newCommand.execute(theParams, returnCommandResult, idString);						}				/**		 * Remove a previously registered <code>ICommand</code>.		 * 		 * @param notification the name of the <code>ICommand</code> mapping to remove.		 */		final public function removeCommand( notification:String ):void		{			commands[ notification ] = null;		}				/**		 * Registers an <code>EventDispatcher</code> with this <code>JSControllerBase</code>.		 * <p> 		 * Registers an event dispatcher with this controller. Events registered here will trigger a default event handler that		 * simply calls the command that's associated with theEventType. Registering events in this way enables a traditional 		 * Command Dispatcher pattern seen in most of the popular frameworks whereby a single event type maps to a single command		 * and parameters are passed through the event itself. By overriding the default handler, however, you achieve a broader		 * implementation (a many-to-one or one-to-many mapping for instance).		 * 		 * @param theEventType A string with the event type to listen for.		 * @param theEventDispatcher A reference to the <code>EventDispatcher</code> instance.		 * @see public function handleEvent ( event:Event):void		 */		public function registerEventDispatcher ( theEventType:String, theEventDispatcher:EventDispatcher ):void		{						// register this controller as a listener			theEventDispatcher.addEventListener(theEventType, handleEvent);					}				/**		 * Processes the result of a <code>JSCommandBase</code> instance. 		 * <p>		 * This is the default <code>returnFunc</code> given to a new <code>JSCommandBase</code>.		 * This method calls the afterFilter() hook method. This method then calls the 		 * original return function supplied in <code>createCommand()</code>.		 * @param theResultObject An object containing the result information from the command.		 */		final public function returnCommandResult(theResultObject:Object):void		{						afterFilter(theResultObject.type);						if (commandLog[theResultObject.id].returnFunc != null) commandLog[theResultObject.id].returnFunc(theResultObject);						// Free up memory			delete commandLog[theResultObject.id];			commandLog[theResultObject.id] = null; 					}			////////////////////////////////////////////////////////////////////////////		//		// Public Event Handlers		//		////////////////////////////////////////////////////////////////////////////			/**		 * The default event handler called by <code>registerEventDispatcher</code>.		 * <p> 		 * This default implementation enables a traditional Command Dispatcher pattern seen		 * in most of the popular frameworks whereby a single event type maps to a single command		 * and parameters are passed through the event itself. By overriding this handler you can 		 * define your own implementation.		 * 		 * @param event An <code>Event</code> with the event type corresponding to a notification string		 * previously registered using <code>addCommand()</code>		 * @see public function registerEventDispatcher ( theEventType:String, theEventDispatcher:EventDispatcher ):void		 */		public function handleEvent ( event:Event ):void		{						if (commands [ event.type ] != null) createCommand(event.type, event);					}			////////////////////////////////////////////////////////////////////////////		//		// Hook Functions		//		////////////////////////////////////////////////////////////////////////////				/**		 *	A method that is called before any Commands have been initialized		 */		protected function preCommandInit():void{}				/**		 *	A method that is called after any Commands have been initialized.		 *	This method should be overriden to perform basic class initialization.		 */		protected function init():void{}				/**		 *	A method that is called before any Command is called.		 *	This method can be overriden to perform pre-commnad filtering logic.		 *	@param theCommandName The name of the command that will be called 		 *	directly after this method ends.		 */		protected function beforeFilter(theNotification:String):void{}				/**		 *	A method that is called after any Command is called.		 *	This method can be overriden to perform post-commnd filtering logic.		 *	@param theCommandName The name of the command that has just finished executing.		 */		protected function afterFilter(theNotification:String):void{}				/**		 *	A method that is called to add Commands that this Command can call in the		 *	course of its duty's. The format for adding a Command should be as follows:		 *	<p>		 *	<code>addCommand ( "getPersonListCommand", GetPersonListCommand );</code>		 *	<p>		 *	If "getPersonListCommand" is the same as an event type registered through 		 *	<code>registerEventDispatcher()</code>, this command will be called automatically		 *	as a result of this Controller receiving the event.		 */		protected function addCommands ():void		{			// This is the place to add commands on initialization though a list			// of addCommand() calls. Commands can be added and removed later with			// calls to addCommand() or removeCommand()			//			// Note: Commands are added as references to the classes. Dispatching 			// a command with createCommand() includes creating an instance of it.			//			// The general format should be:			//			// addCommand ( "getPersonListCommand", GetPersonListCommand );					}				////////////////////////////////////////////////////////////////////////////		// Pseudo Constants - 		// These constants are implemented as getters so that exending classes		// can override the default values.		////////////////////////////////////////////////////////////////////////////				/**		 * Pseudo Constant: Determines the maximum number of commands the controller will remember		 * in it's history.		 */		public function get MAXHISTORY():uint {						return 100; // maximum number of history entries					}			} // Class End	} // Package End